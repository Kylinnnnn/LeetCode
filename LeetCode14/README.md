**思路**记录两种思路。首先是我自己想的，水平扫描，当碰到已经到达字符串最后一位或是出现前后两个字符串对应位置的字符不同时返回答案。按理来说效率应该是还可以的，起码比起下面这个从题解里记录下来的另一个思路比较的次数应该是要少一些的，尤其是在各个字符串长度差别较大时。但实际并不如人意，不是很懂哪里的问题。
![](https://Kylinnnnn.github.io/img/LeetCode14_01.png)
另一种思路是代码中被注释的部分，从题解里看的，是先将其中一条字符串做为答案，再将答案与各字符串进行操作获取最长公共子串，然后取所有最长公共字串里最短的那个。
![](https://Kylinnnnn.github.io/img/LeetCode14_02.png)